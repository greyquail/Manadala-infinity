<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>WebGL Mandala Fractal — 4K & Real-time Zoom</title>
<style>
  html,body{height:100%;margin:0;background:#000;color:#eee;font-family:system-ui,Segoe UI,Roboto;}
  #glcanvas{display:block;width:100vw;height:100vh;}
  #ui{position:fixed;right:12px;top:12px;background:rgba(0,0,0,0.35);padding:10px;border-radius:8px;backdrop-filter:blur(6px);z-index:10}
  button,input,select{margin:6px 4px;font-size:13px}
  label{font-size:13px;color:#ddd}
</style>
</head>
<body>
<canvas id="glcanvas"></canvas>
<div id="ui">
  <div id="info">Formula: <span id="fName">mandelbrot</span> · Iter: <span id="iterVal">512</span></div>
  <div style="margin-top:6px">
    <select id="formula">
      <option value="0">mandelbrot</option>
      <option value="1">multibrot</option>
      <option value="2">burning</option>
      <option value="3">julia</option>
      <option value="4">strange</option>
    </select>
    <button id="randomize">Randomize</button>
    <button id="reset">Reset</button>
  </div>
  <div style="margin-top:6px">
    <label>Max Iter <input id="iter" type="range" min="64" max="2048" value="512" step="16"></label>
  </div>
  <div style="margin-top:6px">
    <label>Refine Delay <input id="refine" type="range" min="0" max="1500" value="500"></label>
  </div>
  <div style="margin-top:6px; font-size:12px; opacity:0.8">Controls: wheel zoom · drag pan · pinch on touch · click randomize</div>
</div>

<script id="frag" type="x-shader/x-fragment">
#ifdef GL_ES
precision highp float;
#endif

uniform vec2 u_resolution;
uniform float u_time;
uniform vec2 u_center;       // fractal center
uniform float u_scale;       // scale (smaller -> zoomed in)
uniform int u_maxIter;
uniform int u_formula;       // 0 mandelbrot,1 multibrot,2 burning,3 julia,4 strange
uniform float u_power;       // for multibrot / julia
uniform vec2 u_juliaC;
uniform float u_seed;        // for palette
uniform float u_symmetry;    // number of slices
uniform int u_mirror;        // mirror boolean
uniform float u_tweak;       // slight tweak / jitter

// ---------- helpers ----------
float rand1(vec2 co){ return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453); }

vec3 hsv2rgb(vec3 c){
    vec3 rgb = clamp( abs(mod(c.x*6.0 + vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );
    return c.z * mix(vec3(1.0), rgb, c.y);
}

// smooth palette generator (deterministic via seed)
vec3 palette(float t){
    // create layered hue using seed
    float s = 0.8;
    float base = mod(u_seed*0.000023 + sin(u_seed*0.00017)*0.5, 1.0);
    float h = base + 0.25 * sin(6.2831 * (t*0.35 + 0.12*u_time*0.05));
    float sat = 0.6 + 0.35 * cos(6.2831 * (t*0.17 + base));
    float val = 0.35 + 0.6 * pow(t,0.7);
    return hsv2rgb(vec3(mod(h,1.0), sat, val));
}

// complex pow via polar (a+ib)^p  with p maybe fractional
vec2 cpow(vec2 z, float p){
    float r = length(z);
    float th = atan(z.y, z.x);
    float rp = pow(r, p);
    float a = rp * cos(th * p);
    float b = rp * sin(th * p);
    return vec2(a,b);
}

// apply kaleidoscope symmetry
vec2 apply_symmetry(vec2 z, float slices, int mirror){
    if(slices <= 1.5) return z;
    float theta = atan(z.y, z.x);
    float r = length(z);
    float slice = 6.28318530718 / slices;
    theta = mod(theta + 1e-6, slice);
    if(mirror==1 && theta > slice*0.5) theta = slice - theta;
    return vec2(r*cos(theta), r*sin(theta));
}

// iterate depending on formula
float iterate_fractal(vec2 c){
    int maxI = u_maxIter;
    vec2 z = vec2(0.0);
    float mu = float(maxI);
    float escape = 1e6;
    if(u_formula == 3){ // julia
        z = c;
        for(int i=0;i<4096;i++){
            if(i >= maxI) break;
            if(u_power==2.0){
                z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + u_juliaC;
            } else {
                z = cpow(z, u_power) + u_juliaC;
            }
            float r2 = dot(z,z);
            if(r2 > 256.0){ 
                float r = sqrt(r2);
                mu = float(i) + 1.0 - log(log(r))/log(max(u_power,2.0));
                break;
            }
        }
    } else if(u_formula == 2){ // burning ship
        z = vec2(0.0);
        for(int i=0;i<4096;i++){
            if(i >= maxI) break;
            z = vec2(abs(z.x), abs(z.y));
            vec2 z2 = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;
            z = z2;
            float r2 = dot(z,z);
            if(r2 > 256.0){
                float r = sqrt(r2);
                mu = float(i) + 1.0 - log(log(r))/log(2.0);
                break;
            }
        }
    } else if(u_formula == 4){ // strange chaotic
        z = vec2(0.0);
        for(int i=0;i<4096;i++){
            if(i >= maxI) break;
            vec2 znew = vec2(sin(z.x*z.x - z.y*z.y) + c.x, tan(2.0*z.x*z.y) + c.y);
            z = znew;
            float r2 = dot(z,z);
            if(!isfinite(r2) || r2 > 1e5){
                float r = sqrt(min(r2, 1e5));
                mu = float(i) + 1.0 - log(max(0.000001, log(r)))/log(2.0);
                break;
            }
        }
    } else { // mandelbrot / multibrot
        z = vec2(0.0);
        for(int i=0;i<4096;i++){
            if(i >= maxI) break;
            if(u_power==2.0){
                z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;
            } else {
                z = cpow(z, u_power) + c;
            }
            float r2 = dot(z,z);
            if(r2 > 256.0){
                float r = sqrt(r2);
                mu = float(i) + 1.0 - log(log(r))/log(max(u_power,2.0));
                break;
            }
        }
    }
    return mu;
}

void main(){
    // pixel coords
    vec2 uv = (gl_FragCoord.xy - 0.5*u_resolution) / u_resolution.y; // centered, keep aspect
    // apply scale and center
    vec2 z = uv * u_scale + u_center;

    // apply kaleidoscope symm in plane before iteration (makes mandala)
    z = apply_symmetry(z, u_symmetry, u_mirror);

    // small jitter to create organic shapes
    z += (rand1(gl_FragCoord.xy + u_seed) - 0.5) * u_tweak;

    float mu = iterate_fractal(z);

    // color mapping
    float iterNorm = clamp(mu / float(u_maxIter), 0.0, 1.0);
    // boost small details
    float t = pow(iterNorm, 0.65);

    vec3 col;
    if(mu >= float(u_maxIter) - 0.5){
        // interior - dark but tinted
        col = vec3(0.03, 0.04, 0.05) + 0.2 * palette(t*0.6);
    } else {
        col = palette(t + 0.02 * sin(u_time*0.0005 + t*12.0));
    }

    // soft vignette
    float d = length((gl_FragCoord.xy/u_resolution.xy) - 0.5);
    col *= 1.0 - smoothstep(0.55, 0.95, d);

    // optional halo/glow (simulate bloom by boosting bright parts)
    float brightness = dot(col, vec3(0.3,0.6,0.1));
    col += pow(max(0.0, brightness - 0.45), 2.0) * 0.8;

    gl_FragColor = vec4(col, 1.0);
}
</script>

<script>
(() => {
  const canvas = document.getElementById('glcanvas');
  const gl = canvas.getContext('webgl', { antialias: true, preserveDrawingBuffer: false });
  if(!gl){ alert('WebGL not supported'); return; }

  // --- utilities ---
  function compileShader(src, type){
    const sh = gl.createShader(type);
    gl.shaderSource(sh, src);
    gl.compileShader(sh);
    if(!gl.getShaderParameter(sh, gl.COMPILE_STATUS)){
      console.error(gl.getShaderInfoLog(sh));
      throw 'Shader compile error';
    }
    return sh;
  }
  function createProgram(vsSrc, fsSrc){
    const pr = gl.createProgram();
    const vs = compileShader(vsSrc, gl.VERTEX_SHADER);
    const fs = compileShader(fsSrc, gl.FRAGMENT_SHADER);
    gl.attachShader(pr, vs);
    gl.attachShader(pr, fs);
    gl.linkProgram(pr);
    if(!gl.getProgramParameter(pr, gl.LINK_STATUS)) {
      console.error(gl.getProgramInfoLog(pr));
      throw 'Program link error';
    }
    return pr;
  }

  // vertex shader (simple)
  const vsSrc = `
    attribute vec2 a_pos;
    void main(){ gl_Position = vec4(a_pos,0.0,1.0); }
  `;

  // fragment shader from DOM
  const fsSrc = document.getElementById('frag').textContent;

  const program = createProgram(vsSrc, fsSrc);
  gl.useProgram(program);

  // fullscreen quad
  const buf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,1,1]), gl.STATIC_DRAW);
  const aPos = gl.getAttribLocation(program, 'a_pos');
  gl.enableVertexAttribArray(aPos);
  gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

  // uniforms
  const u_resolution = gl.getUniformLocation(program, 'u_resolution');
  const u_time = gl.getUniformLocation(program, 'u_time');
  const u_center = gl.getUniformLocation(program, 'u_center');
  const u_scale = gl.getUniformLocation(program, 'u_scale');
  const u_maxIter = gl.getUniformLocation(program, 'u_maxIter');
  const u_formula = gl.getUniformLocation(program, 'u_formula');
  const u_power = gl.getUniformLocation(program, 'u_power');
  const u_juliaC = gl.getUniformLocation(program, 'u_juliaC');
  const u_seed = gl.getUniformLocation(program, 'u_seed');
  const u_symmetry = gl.getUniformLocation(program, 'u_symmetry');
  const u_mirror = gl.getUniformLocation(program, 'u_mirror');
  const u_tweak = gl.getUniformLocation(program, 'u_tweak');

  // UI elements
  const formulaSel = document.getElementById('formula');
  const randomizeBtn = document.getElementById('randomize');
  const resetBtn = document.getElementById('reset');
  const iterSlider = document.getElementById('iter');
  const refineSlider = document.getElementById('refine');
  const iterVal = document.getElementById('iterVal');
  const fName = document.getElementById('fName');

  // state
  let devicePixelRatio = Math.max(1, window.devicePixelRatio || 1);
  let targetRes = Math.min(3840, Math.floor(window.innerWidth * devicePixelRatio)); // cap at 4k width
  let width = window.innerWidth, height = window.innerHeight;
  let DPRcap = Math.min(devicePixelRatio, 2.5); // avoid extreme DPR blowups
  function resizeCanvas(){
    devicePixelRatio = Math.max(1, window.devicePixelRatio || 1);
    width = window.innerWidth; height = window.innerHeight;
    // choose render resolution based on DPRcap - multiply to reach 4k if needed
    const targetW = Math.min(Math.max(1280, Math.floor(width * DPRcap)), 3840);
    const targetH = Math.min(Math.floor(targetW * (height/width)), 2160);
    canvas.style.width = width + 'px';
    canvas.style.height = height + 'px';
    canvas.width = targetW;
    canvas.height = targetH;
    gl.viewport(0,0, canvas.width, canvas.height);
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  // fractal params
  let center = { x: -0.5, y: 0.0 };
  let scale = 3.5; // world size mapped to -scale..scale in y dimension
  let targetScale = scale;
  let formula = 0;
  let power = 2.0;
  let juliaC = { x: -0.4, y: 0.6 };
  let maxIter = parseInt(iterSlider.value);
  iterVal.innerText = maxIter;
  let seed = Math.floor(Math.random()*1e9);
  let symmetry = 6;
  let mirror = 1;
  let tweak = 0.0008;

  // progressive refine: low res while interaction, then refine to full
  let isInteracting = false;
  let lastInteract = performance.now();
  let refineDelay = parseInt(refineSlider.value);

  // input: wheel zoom + drag pan + touch
  let isDown = false;
  let lastPos = null;

  canvas.addEventListener('mousedown', (e) => {
    isDown = true; lastPos = {x:e.clientX, y:e.clientY}; isInteracting = true; lastInteract = performance.now();
  });
  window.addEventListener('mouseup', (e) => { isDown = false; lastPos = null; lastInteract = performance.now(); });
  window.addEventListener('mousemove', (e) => {
    if(!isDown) return;
    const dx = e.clientX - lastPos.x;
    const dy = e.clientY - lastPos.y;
    lastPos = {x:e.clientX, y:e.clientY};
    // translate screen pixels to fractal world
    const vw = scale;
    const sx = (dx / canvas.clientWidth) * vw;
    const sy = (dy / canvas.clientHeight) * vw * (canvas.clientHeight/canvas.clientWidth);
    center.x -= sx; center.y += sy;
    isInteracting = true; lastInteract = performance.now();
  });

  canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    const delta = Math.sign(e.deltaY);
    // zoom around mouse pos
    const rect = canvas.getBoundingClientRect();
    const px = (e.clientX - rect.left) / rect.width;
    const py = (e.clientY - rect.top) / rect.height;
    const zoomFactor = Math.pow(1.02, delta * 8.0); // tune sensitivity
    // map screen point to world coords
    const wx = (px - 0.5) * scale * (canvas.height/canvas.width) + center.x;
    const wy = (0.5 - py) * scale + center.y;
    // update center so the point under cursor stays fixed
    center.x = wx + (center.x - wx) * zoomFactor;
    center.y = wy + (center.y - wy) * zoomFactor;
    scale *= zoomFactor;
    isInteracting = true; lastInteract = performance.now();
  }, {passive:false});

  // touch
  let lastTouchDist = null, lastTouchCenter = null;
  canvas.addEventListener('touchstart', (e) => {
    isInteracting = true; lastInteract = performance.now();
    if(e.touches.length === 2){
      const a = e.touches[0], b = e.touches[1];
      lastTouchDist = Math.hypot(a.clientX-b.clientX, a.clientY-b.clientY);
      lastTouchCenter = { x: (a.clientX + b.clientX)/2, y: (a.clientY+b.clientY)/2 };
    } else if(e.touches.length === 1){
      lastPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
    }
  }, {passive:true});
  canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    if(e.touches.length === 2){
      const a = e.touches[0], b = e.touches[1];
      const dist = Math.hypot(a.clientX-b.clientX, a.clientY-b.clientY);
      const centerTouch = { x: (a.clientX + b.clientX)/2, y: (a.clientY+b.clientY)/2 };
      if(lastTouchDist){
        const zoomFactor = lastTouchDist / dist;
        // compute world coords at touch center and zoom about it
        const rect = canvas.getBoundingClientRect();
        const px = (centerTouch.x - rect.left) / rect.width;
        const py = (centerTouch.y - rect.top) / rect.height;
        const wx = (px - 0.5) * scale * (canvas.height/canvas.width) + center.x;
        const wy = (0.5 - py) * scale + center.y;
        center.x = wx + (center.x - wx) * zoomFactor;
        center.y = wy + (center.y - wy) * zoomFactor;
        scale *= zoomFactor;
      }
      lastTouchDist = dist;
      lastTouchCenter = centerTouch;
    } else if(e.touches.length === 1 && lastPos){
      const dx = e.touches[0].clientX - lastPos.x;
      const dy = e.touches[0].clientY - lastPos.y;
      lastPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
      const vw = scale;
      const sx = (dx / canvas.clientWidth) * vw;
      const sy = (dy / canvas.clientHeight) * vw * (canvas.clientHeight/canvas.clientWidth);
      center.x -= sx; center.y += sy;
    }
    isInteracting = true; lastInteract = performance.now();
  }, {passive:false});
  window.addEventListener('touchend', () => { lastTouchDist = null; lastTouchCenter = null; lastPos = null; lastInteract = performance.now(); });

  // UI bindings
  formulaSel.addEventListener('change', ()=> {
    formula = parseInt(formulaSel.value);
    updateInfo();
  });
  iterSlider.addEventListener('input', ()=> {
    maxIter = parseInt(iterSlider.value);
    iterVal.innerText = maxIter;
  });
  refineSlider.addEventListener('input', ()=> {
    // no immediate effect other than UI
  });

  randomizeBtn.addEventListener('click', ()=> {
    randomize();
  });
  resetBtn.addEventListener('click', ()=> {
    center = {x:-0.5, y:0.0}; scale = 3.5; power = 2.0; symmetry = 6; mirror = 1; juliaC = {x:-0.4, y:0.6}; seed = Math.floor(Math.random()*1e9);
    updateInfo();
  });

  function updateInfo(){
    fName.innerText = ['mandelbrot','multibrot','burning','julia','strange'][formula];
    document.getElementById('iterVal').innerText = maxIter;
  }

  function randomize(){
    seed = Math.floor(Math.random()*1e9);
    symmetry = 2 + Math.floor(Math.random()*12);
    mirror = (Math.random() > 0.5) ? 1 : 0;
    power = 2 + Math.random()*4;
    juliaC = { x:(Math.random()*2-1)*1.2, y:(Math.random()*2-1)*1.2 };
    // choose random formula sometimes
    formula = Math.floor(Math.random()*5);
    formulaSel.value = formula;
    updateInfo();
  }

  randomize();

  // animation loop
  let start = performance.now();
  function draw(t){
    // progressive refine: while interacting render at reduced resolution (already handled by canvas size), then when idle and past refine delay, re-render at full resolution by resizing canvas to DPRcap high
    const now = performance.now();
    if(isInteracting){
      lastInteract = now;
    } else {
      // determine if enough idle
      if(now - lastInteract > parseInt(refineSlider.value)){
        // if we aren't at full DPR, upscale canvas to full high res
        // (we used a single canvas with target resolution; for more sophisticated progressive refine you'd maintain two framebuffers)
      }
    }

    // set uniforms
    gl.viewport(0,0, canvas.width, canvas.height);
    gl.uniform2f(u_resolution, canvas.width, canvas.height);
    gl.uniform1f(u_time, (t - start));
    gl.uniform2f(u_center, center.x, center.y);
    // scale: we want world height = scale -> used in shader multiply by y
    // choose u_scale such that uv * u_scale maps to world coords; uv used earlier sets height=1 -> multiply by scale
    gl.uniform1f(u_scale, scale);
    gl.uniform1i(u_maxIter, maxIter);
    gl.uniform1i(u_formula, formula);
    gl.uniform1f(u_power, power);
    gl.uniform2f(u_juliaC, juliaC.x, juliaC.y);
    gl.uniform1f(u_seed, seed);
    gl.uniform1f(u_symmetry, symmetry);
    gl.uniform1i(u_mirror, mirror);
    gl.uniform1f(u_tweak, tweak);

    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    requestAnimationFrame(draw);
  }
  requestAnimationFrame(draw);

  // expose some keyboard shortcuts
  window.addEventListener('keydown', (e) => {
    if(e.key === 'r' || e.key === 'R') randomize();
    if(e.key === ' '){ // freeze toggle
      // simple toggle: toggle tweak to 0 to 'stop' minor movement
      tweak = tweak > 0 ? 0.0 : 0.0008;
    }
  });

  // initial uniforms set
  gl.uniform2f(u_resolution, canvas.width, canvas.height);
})();
</script>
</body>
</html>
