<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>EXPLORING STRANGE MANDELBROT UNIVERSE</title>
<style>
  html,body{height:100%;margin:0;background:#000;overflow:hidden;font-family:'Segoe UI', system-ui, sans-serif;}
  canvas{display:block; width:100vw; height:100vh; touch-action:none; -webkit-tap-highlight-color:transparent;}
  
  /* Universe Info Panel */
  #universe-info {
    position: fixed;
    left: 20px;
    top: 20px;
    background: rgba(0, 0, 0, 0.75);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(79, 195, 247, 0.3);
    border-radius: 12px;
    padding: 15px;
    color: white;
    max-width: 320px;
    z-index: 1000;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
  }
  
  #universe-info h2 {
    margin: 0 0 8px 0;
    font-size: 1.2em;
    color: #4fc3f7;
    font-weight: 600;
  }
  
  #universe-info p {
    margin: 0 0 12px 0;
    font-size: 0.9em;
    line-height: 1.4;
    color: #e0e0e0;
  }
  
  #coordinates {
    font-family: 'Courier New', monospace;
    background: rgba(0, 30, 60, 0.5);
    padding: 8px 12px;
    border-radius: 6px;
    font-size: 0.85em;
    margin-bottom: 12px;
  }
  
  #universe-properties {
    list-style: none;
    padding: 0;
    margin: 0 0 12px 0;
  }
  
  #universe-properties li {
    margin: 4px 0;
    font-size: 0.85em;
    display: flex;
    align-items: center;
  }
  
  .property-label {
    color: #bb86fc;
    min-width: 100px;
    display: inline-block;
  }
  
  .property-value {
    color: #ffffff;
    font-weight: 500;
  }
  
  /* Controls */
  #controls {
    position: fixed;
    right: 20px;
    top: 20px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    z-index: 1000;
  }
  
  .control-btn {
    background: rgba(0, 0, 0, 0.75);
    border: 1px solid rgba(79, 195, 247, 0.3);
    color: white;
    border-radius: 50%;
    width: 50px;
    height: 50px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s ease;
    font-size: 1.2em;
  }
  
  .control-btn:hover {
    background: rgba(79, 195, 247, 0.2);
    border-color: #4fc3f7;
    transform: scale(1.1);
  }
  
  /* Discovery Counter */
  #discovery-counter {
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: rgba(0, 0, 0, 0.75);
    border: 1px solid rgba(79, 195, 247, 0.3);
    border-radius: 12px;
    padding: 12px 16px;
    color: white;
    z-index: 1000;
    text-align: center;
    min-width: 100px;
  }
  
  #discovery-count {
    font-size: 1.8em;
    font-weight: bold;
    color: #4fc3f7;
    display: block;
  }
  
  .discovery-label {
    font-size: 0.8em;
    color: #81c784;
    text-transform: uppercase;
    letter-spacing: 1px;
  }
  
  /* Mode Indicator */
  .mode-indicator {
    position: fixed;
    bottom: 20px;
    left: 20px;
    background: rgba(0, 0, 0, 0.75);
    border: 1px solid #4fc3f7;
    border-radius: 10px;
    padding: 8px 12px;
    color: #4fc3f7;
    font-size: 0.85em;
    z-index: 1000;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  
  .pulse {
    width: 8px;
    height: 8px;
    background: #4fc3f7;
    border-radius: 50%;
    animation: pulse 2s infinite;
  }
  
  @keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.3; }
    100% { opacity: 1; }
  }
  
  /* Error box */
  #err{
    position:fixed;left:8px;top:8px;background:#111a;padding:8px 10px;border-radius:6px;color:#fff;font-family:system-ui;opacity:0.9;display:none;z-index:9999
  }
  
  /* Mobile responsive */
  @media (max-width: 768px) {
    #universe-info {
      left: 10px;
      right: 10px;
      top: 10px;
      max-width: none;
      padding: 12px;
    }
    
    #controls {
      right: 10px;
      top: 10px;
    }
    
    #discovery-counter {
      bottom: 10px;
      right: 10px;
      padding: 10px 14px;
    }
    
    .mode-indicator {
      bottom: 10px;
      left: 10px;
      padding: 6px 10px;
      font-size: 0.8em;
    }
  }
</style>
</head>
<body>
<!-- Universe Info Panel -->
<div id="universe-info">
  <h2 id="universe-name">COSMIC MANDELBROT FIELD</h2>
  <p id="universe-description">Infinite patterns unfolding across quantum dimensions.</p>
  
  <div id="coordinates">
    <div>X: <span id="coord-x">0.000000</span></div>
    <div>Y: <span id="coord-y">0.000000</span></div>
    <div>Zoom: 10<sup id="zoom-level">0</sup></div>
  </div>
  
  <h3 style="margin: 0 0 8px 0; color: #81c784; font-size: 0.9em;">UNIVERSE PROPERTIES</h3>
  <ul id="universe-properties">
    <li><span class="property-label">DIMENSIONS:</span> <span class="property-value" id="prop-dimensions">‚àû</span></li>
    <li><span class="property-label">ENTROPY:</span> <span class="property-value" id="prop-entropy">5.42</span></li>
    <li><span class="property-label">SYMMETRY:</span> <span class="property-value" id="prop-symmetry">8</span></li>
    <li><span class="property-label">CHAOS:</span> <span class="property-value" id="prop-chaos">0.67</span></li>
    <li><span class="property-label">ITERATIONS:</span> <span class="property-value" id="prop-iterations">512</span></li>
  </ul>
</div>

<!-- Controls -->
<div id="controls">
  <div class="control-btn" id="randomize-btn" title="New Universe">üåÄ</div>
  <div class="control-btn" id="auto-btn" title="Auto-Explore">‚ñ∂Ô∏è</div>
  <div class="control-btn" id="capture-btn" title="Capture">üì∏</div>
</div>

<!-- Discovery Counter -->
<div id="discovery-counter">
  <span id="discovery-count">1</span>
  <span class="discovery-label">DISCOVERED</span>
</div>

<!-- Mode Indicator -->
<div class="mode-indicator">
  <div class="pulse"></div>
  <span id="mode-text">EXPLORING</span>
</div>

<!-- Error Box -->
<div id="err">WebGL unavailable ‚Äî using fallback.</div>

<!-- Main Canvas -->
<canvas id="c"></canvas>

<script>
/* ---------- UNIVERSE EXPLORER - Working Fractal Renderer ---------- */

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const errBox = document.getElementById('err');
const universeName = document.getElementById('universe-name');
const universeDesc = document.getElementById('universe-description');
const coordX = document.getElementById('coord-x');
const coordY = document.getElementById('coord-y');
const zoomLevel = document.getElementById('zoom-level');
const propDimensions = document.getElementById('prop-dimensions');
const propEntropy = document.getElementById('prop-entropy');
const propSymmetry = document.getElementById('prop-symmetry');
const propChaos = document.getElementById('prop-chaos');
const propIterations = document.getElementById('prop-iterations');
const discoveryCount = document.getElementById('discovery-count');
const modeText = document.getElementById('mode-text');

let discoveryCounter = 1;
let autoExploreMode = false;
let animationId = null;
let lastTime = 0;

// Universe data
const universeNames = [
  "NEBULA FRACTAL CLOUD",
  "QUANTUM MANDELBROT",
  "CHAOTIC JULIA SPHERE",
  "COSMIC SYMMETRY FIELD",
  "INFINITE PATTERN UNIVERSE",
  "HYPERBOLIC MANDALA",
  "BURNING SHIP NEBULA",
  "PSYCHEDELIC DIMENSION",
  "GALACTIC FRACTAL",
  "MULTI-VERSE PATTERN"
];

const universeDescriptions = [
  "Swirling cosmic clouds of infinite mathematical complexity.",
  "Quantum fluctuations create ever-changing fractal landscapes.",
  "Chaotic yet beautiful spherical patterns defying geometry.",
  "Perfect symmetry emerges from mathematical chaos.",
  "Patterns within patterns, repeating into infinity.",
  "Non-Euclidean geometry creates mind-bending visual spaces.",
  "The famous Burning Ship formula reveals cosmic structures.",
  "Vibrant colors and patterns from psychedelic mathematics.",
  "Galactic-scale fractal formations across the void.",
  "Multiple mathematical universes overlapping and interacting."
];

// Current view parameters
let params = {
  centerX: -0.5,
  centerY: 0,
  scale: 3.5,
  maxIter: 512,
  symmetry: 8,
  mirror: 1,
  colorSeed: Math.random() * 1000,
  colorSpeed: 0.5,
  colorOffset: 0,
  autoZoom: false,
  zoomSpeed: 0.999,
  driftX: 0.0001,
  driftY: 0.0001
};

// Color palettes
const palettes = [
  // Cosmic Blue/Purple
  [[0,7,100], [42,100,100], [193,100,50], [260,100,70], [300,100,50]],
  // Nebula Red/Orange
  [[0,100,50], [30,100,100], [60,100,100], [330,100,70], [280,100,50]],
  // Galactic Green/Blue
  [[120,100,30], [180,100,50], [210,100,70], [240,100,50], [270,100,30]],
  // Psychedelic Rainbow
  [[0,100,100], [60,100,100], [120,100,100], [180,100,100], [240,100,100], [300,100,100]],
  // Warm Cosmic
  [[10,100,50], [40,100,80], [200,100,30], [280,100,60], [320,100,40]]
];

// Initialize
function init() {
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);
  
  // Setup controls
  document.getElementById('randomize-btn').addEventListener('click', randomizeUniverse);
  document.getElementById('auto-btn').addEventListener('click', toggleAutoExplore);
  document.getElementById('capture-btn').addEventListener('click', captureUniverse);
  
  // Setup interaction
  setupInteractions();
  
  // Start animation
  updateUniverseInfo();
  animate();
}

// Resize canvas
function resizeCanvas() {
  const dpr = window.devicePixelRatio || 1;
  canvas.width = window.innerWidth * dpr;
  canvas.height = window.innerHeight * dpr;
  canvas.style.width = window.innerWidth + 'px';
  canvas.style.height = window.innerHeight + 'px';
  ctx.scale(dpr, dpr);
}

// Convert HSL to RGB
function hslToRgb(h, s, l) {
  h /= 360;
  s /= 100;
  l /= 100;
  let r, g, b;
  
  if (s === 0) {
    r = g = b = l;
  } else {
    const hue2rgb = (p, q, t) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    };
    
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }
  
  return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
}

// Get color from palette
function getColor(t, paletteIndex = 0) {
  const palette = palettes[paletteIndex % palettes.length];
  const idx = (t * (palette.length - 1)) % palette.length;
  const idx2 = Math.ceil(idx);
  const idx1 = Math.floor(idx);
  const frac = idx - idx1;
  
  const [h1, s1, l1] = palette[idx1];
  const [h2, s2, l2] = palette[idx2];
  
  const h = h1 + (h2 - h1) * frac;
  const s = s1 + (s2 - s1) * frac;
  const l = l1 + (l2 - l1) * frac;
  
  return hslToRgb(h, s, l);
}

// Mandelbrot calculation with symmetry
function mandelbrot(x, y, maxIter) {
  let zx = 0;
  let zy = 0;
  const zx2 = 0;
  const zy2 = 0;
  
  // Apply symmetry
  if (params.symmetry > 1) {
    const angle = Math.atan2(y, x);
    const slice = (2 * Math.PI) / params.symmetry;
    let newAngle = angle % slice;
    if (params.mirror && newAngle > slice / 2) {
      newAngle = slice - newAngle;
    }
    const r = Math.sqrt(x * x + y * y);
    x = r * Math.cos(newAngle);
    y = r * Math.sin(newAngle);
  }
  
  let iter = 0;
  while (iter < maxIter && (zx * zx + zy * zy) < 4) {
    const xtemp = zx * zx - zy * zy + x;
    zy = 2 * zx * zy + y;
    zx = xtemp;
    iter++;
  }
  
  if (iter === maxIter) return maxIter;
  
  // Smooth iteration count
  const log_zn = Math.log(zx * zx + zy * zy) / 2;
  const nu = Math.log(log_zn / Math.log(2)) / Math.log(2);
  return iter + 1 - nu;
}

// Render the fractal
function render() {
  const width = canvas.width / (window.devicePixelRatio || 1);
  const height = canvas.height / (window.devicePixelRatio || 1);
  
  const imageData = ctx.createImageData(width, height);
  const data = imageData.data;
  
  const aspect = width / height;
  const scale = params.scale;
  const centerX = params.centerX;
  const centerY = params.centerY;
  const maxIter = params.maxIter;
  
  // Time-based color animation
  params.colorOffset += 0.01 * params.colorSpeed;
  if (params.colorOffset > 1000) params.colorOffset -= 1000;
  
  for (let py = 0; py < height; py++) {
    for (let px = 0; px < width; px++) {
      const x = (px / width - 0.5) * scale * aspect + centerX;
      const y = (py / height - 0.5) * scale + centerY;
      
      const iter = mandelbrot(x, y, maxIter);
      
      const idx = (py * width + px) * 4;
      
      if (iter === maxIter) {
        // Inside the set - dark color
        data[idx] = 0;
        data[idx + 1] = 0;
        data[idx + 2] = 20;
        data[idx + 3] = 255;
      } else {
        // Outside the set - colorful
        const t = (iter / maxIter + params.colorOffset) % 1;
        const color = getColor(t, Math.floor(params.colorSeed) % palettes.length);
        
        data[idx] = color[0];
        data[idx + 1] = color[1];
        data[idx + 2] = color[2];
        data[idx + 3] = 255;
      }
    }
  }
  
  ctx.putImageData(imageData, 0, 0);
}

// Animation loop
function animate(timestamp) {
  if (!lastTime) lastTime = timestamp;
  const deltaTime = timestamp - lastTime;
  lastTime = timestamp;
  
  // Auto-exploration movement
  if (autoExploreMode) {
    params.centerX += Math.sin(timestamp * 0.0001) * 0.0003 * deltaTime;
    params.centerY += Math.cos(timestamp * 0.00007) * 0.0002 * deltaTime;
    
    if (params.autoZoom) {
      params.scale *= params.zoomSpeed;
      if (params.scale < 0.0001 || params.scale > 100) {
        params.zoomSpeed = 1 / params.zoomSpeed;
      }
    }
    
    params.colorOffset += 0.002 * deltaTime;
  }
  
  render();
  updateUniverseInfo();
  
  animationId = requestAnimationFrame(animate);
}

// Update UI info
function updateUniverseInfo() {
  coordX.textContent = params.centerX.toFixed(6);
  coordY.textContent = params.centerY.toFixed(6);
  zoomLevel.textContent = Math.floor(Math.log10(1/params.scale));
  
  propSymmetry.textContent = params.symmetry;
  propIterations.textContent = params.maxIter;
  
  // Calculate dynamic properties
  const entropy = 2 + Math.sin(params.centerX * 10) * 3 + Math.cos(params.centerY * 10) * 2;
  propEntropy.textContent = entropy.toFixed(2);
  
  const chaos = 0.3 + Math.abs(params.centerX) * 0.2 + Math.abs(params.centerY) * 0.1;
  propChaos.textContent = chaos.toFixed(2);
}

// Randomize universe
function randomizeUniverse() {
  const nameIndex = Math.floor(Math.random() * universeNames.length);
  const descIndex = Math.floor(Math.random() * universeDescriptions.length);
  
  universeName.textContent = universeNames[nameIndex];
  universeDesc.textContent = universeDescriptions[descIndex];
  
  // Random parameters
  params.centerX = (Math.random() - 0.5) * 2;
  params.centerY = (Math.random() - 0.5) * 1.5;
  params.scale = 0.5 + Math.random() * 4;
  params.maxIter = 256 + Math.floor(Math.random() * 512);
  params.symmetry = 2 + Math.floor(Math.random() * 12);
  params.mirror = Math.random() > 0.5 ? 1 : 0;
  params.colorSeed = Math.random() * 1000;
  params.colorSpeed = 0.1 + Math.random() * 0.5;
  
  // Increment discovery counter
  discoveryCounter++;
  discoveryCount.textContent = discoveryCounter;
  
  // Visual feedback
  canvas.style.filter = 'brightness(1.5)';
  setTimeout(() => {
    canvas.style.filter = 'brightness(1)';
  }, 200);
}

// Toggle auto-explore
function toggleAutoExplore() {
  autoExploreMode = !autoExploreMode;
  modeText.textContent = autoExploreMode ? 'AUTO-EXPLORING' : 'EXPLORING';
  
  const autoBtn = document.getElementById('auto-btn');
  if (autoExploreMode) {
    autoBtn.innerHTML = '‚è∏Ô∏è';
    autoBtn.style.background = 'rgba(79, 195, 247, 0.3)';
    autoBtn.style.borderColor = '#4fc3f7';
    params.autoZoom = true;
  } else {
    autoBtn.innerHTML = '‚ñ∂Ô∏è';
    autoBtn.style.background = 'rgba(0, 0, 0, 0.75)';
    autoBtn.style.borderColor = 'rgba(79, 195, 247, 0.3)';
    params.autoZoom = false;
  }
}

// Capture universe
function captureUniverse() {
  try {
    // Create a temporary canvas with high resolution
    const tempCanvas = document.createElement('canvas');
    const tempCtx = tempCanvas.getContext('2d');
    
    // Set high resolution for capture
    tempCanvas.width = 1920;
    tempCanvas.height = 1080;
    
    // Save current parameters
    const savedParams = { ...params };
    const savedWidth = canvas.width;
    const savedHeight = canvas.height;
    
    // Temporarily update canvas for capture
    canvas.width = 1920;
    canvas.height = 1080;
    
    // Render at high resolution
    render();
    
    // Get data URL
    const dataURL = canvas.toDataURL('image/png');
    
    // Restore original state
    canvas.width = savedWidth;
    canvas.height = savedHeight;
    Object.assign(params, savedParams);
    
    // Download
    const link = document.createElement('a');
    link.download = `universe-${Date.now()}.png`;
    link.href = dataURL;
    link.click();
    
    // Visual feedback
    const captureBtn = document.getElementById('capture-btn');
    captureBtn.innerHTML = '‚úÖ';
    setTimeout(() => {
      captureBtn.innerHTML = 'üì∏';
    }, 1000);
  } catch (e) {
    console.error('Failed to capture:', e);
    alert('Failed to capture image. Please try again.');
  }
}

// Setup mouse/touch interactions
function setupInteractions() {
  let isDragging = false;
  let lastX, lastY;
  
  // Mouse drag
  canvas.addEventListener('mousedown', (e) => {
    isDragging = true;
    lastX = e.clientX;
    lastY = e.clientY;
    e.preventDefault();
  });
  
  canvas.addEventListener('mousemove', (e) => {
    if (!isDragging) return;
    
    const dx = e.clientX - lastX;
    const dy = e.clientY - lastY;
    
    params.centerX -= (dx / canvas.width) * params.scale * 2;
    params.centerY += (dy / canvas.height) * params.scale * 2;
    
    lastX = e.clientX;
    lastY = e.clientY;
    
    e.preventDefault();
  });
  
  canvas.addEventListener('mouseup', () => {
    isDragging = false;
  });
  
  canvas.addEventListener('mouseleave', () => {
    isDragging = false;
  });
  
  // Touch drag
  canvas.addEventListener('touchstart', (e) => {
    if (e.touches.length === 1) {
      isDragging = true;
      lastX = e.touches[0].clientX;
      lastY = e.touches[0].clientY;
      e.preventDefault();
    }
  });
  
  canvas.addEventListener('touchmove', (e) => {
    if (!isDragging || e.touches.length !== 1) return;
    
    const dx = e.touches[0].clientX - lastX;
    const dy = e.touches[0].clientY - lastY;
    
    params.centerX -= (dx / canvas.width) * params.scale * 2;
    params.centerY += (dy / canvas.height) * params.scale * 2;
    
    lastX = e.touches[0].clientX;
    lastY = e.touches[0].clientY;
    
    e.preventDefault();
  });
  
  canvas.addEventListener('touchend', () => {
    isDragging = false;
  });
  
  // Zoom with wheel
  canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    const zoomFactor = e.deltaY > 0 ? 1.1 : 0.9;
    const scaleFactor = 1 / zoomFactor;
    
    // Zoom towards cursor
    const wx = (x / canvas.width - 0.5) * params.scale * 2 + params.centerX;
    const wy = (0.5 - y / canvas.height) * params.scale * 2 + params.centerY;
    
    params.centerX = wx + (params.centerX - wx) * scaleFactor;
    params.centerY = wy + (params.centerY - wy) * scaleFactor;
    params.scale *= scaleFactor;
    
    // Limit zoom
    params.scale = Math.max(0.0001, Math.min(100, params.scale));
  }, { passive: false });
  
  // Double-click to toggle auto-explore
  let lastClick = 0;
  canvas.addEventListener('click', (e) => {
    const now = Date.now();
    if (now - lastClick < 300) {
      toggleAutoExplore();
    }
    lastClick = now;
  });
}

// Initialize everything
init();

// Error handling
window.addEventListener('error', (e) => {
  console.error('Fatal error:', e);
  errBox.style.display = 'block';
  errBox.textContent = 'Error in universe renderer. Refreshing...';
  setTimeout(() => {
    location.reload();
  }, 3000);
});
</script>
</body>
</html>
