<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Mandala Screensaver (fixed)</title>
<style>
  html,body{height:100%;margin:0;background:#000;overflow:hidden}
  canvas{display:block; width:100vw; height:100vh; touch-action:none; -webkit-tap-highlight-color:transparent;}
  /* small error/banner only shown when there is a fatal problem (kept hidden otherwise) */
  #err{position:fixed;left:8px;top:8px;background:#111a;padding:8px 10px;border-radius:6px;color:#fff;font-family:system-ui;opacity:0.9;display:none;z-index:9999}
</style>
</head>
<body>
<div id="err">WebGL unavailable — using fallback.</div>
<canvas id="c"></canvas>

<script>
/* ---------- Robust Mandala Screensaver (WebGL2 primary, WebGL1 fallback, CPU fallback) ---------- */

const canvas = document.getElementById('c');
const errBox = document.getElementById('err');

function logErr(msg){
  console.warn(msg);
  errBox.style.display = 'block';
  errBox.textContent = msg;
  setTimeout(()=> errBox.style.display = 'none', 3500);
}

// detect WebGL2 then WebGL1
let gl = canvas.getContext('webgl2', {antialias:true});
let isWebGL2 = true;
if(!gl){
  gl = canvas.getContext('webgl', {antialias:true}) || canvas.getContext('experimental-webgl');
  isWebGL2 = false;
}
if(!gl){
  logErr('No WebGL — falling back to CPU renderer');
  startCPU();
} else {
  startGL(gl, isWebGL2);
}

/* ---------- CPU fallback (very simple fractal so user sees something) ---------- */
function startCPU(){
  const ctx = canvas.getContext('2d');
  function resize(){
    canvas.width = Math.max(320, window.innerWidth);
    canvas.height = Math.max(240, window.innerHeight);
  }
  window.addEventListener('resize', resize);
  resize();
  let seed = Math.floor(Math.random()*1e9);
  function palette(i){
    return `hsl(${(i*7 + (seed%360))%360} 80% ${30 + (i%50)/2}%)`;
  }
  function draw(){
    const w = canvas.width, h = canvas.height;
    const img = ctx.createImageData(w,h);
    let idx=0;
    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        // normalized coords
        let nx = (x/w - 0.5) * 3;
        let ny = (y/h - 0.5) * 2;
        let a=0,b=0, ca=nx*1.1, cb=ny*1.1;
        let n=0;
        for(;n<80;n++){
          let aa = a*a - b*b + ca;
          let bb = 2*a*b + cb;
          a = aa; b = bb;
          if(a*a + b*b > 16) break;
        }
        const shade = n < 80 ? (n/80) : 0;
        // convert hsl approx
        const hue = (shade*360 + seed%360) % 360;
        const c = hsvToRgb(hue, 0.75, 0.5 + 0.5*shade);
        img.data[idx++] = c[0]; img.data[idx++] = c[1]; img.data[idx++] = c[2]; img.data[idx++] = 255;
      }
    }
    ctx.putImageData(img,0,0);
    requestAnimationFrame(draw);
  }
  // small hsv->rgb helper
  function hsvToRgb(h,s,v){
    h = (h%360+360)%360; s=Math.max(0,Math.min(1,s)); v=Math.max(0,Math.min(1,v));
    const c = v*s; const x = c*(1-Math.abs((h/60)%2-1)); const m = v-c;
    let r=0,g=0,b=0;
    if(h<60){ r=c; g=x; b=0; } else if(h<120){ r=x; g=c; b=0; } else if(h<180){ r=0; g=c; b=x; }
    else if(h<240){ r=0; g=x; b=c; } else if(h<300){ r=x; g=0; b=c; } else { r=c; g=0; b=x; }
    return [Math.round((r+m)*255), Math.round((g+m)*255), Math.round((b+m)*255)];
  }
  draw();
}

/* ---------- GL branch (attempt to run WebGL2; fallback to WebGL1 subset) ---------- */
function startGL(gl, isWebGL2){
  // small helper wrappers
  function compile(type, src){
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
      const info = gl.getShaderInfoLog(s);
      console.error('Shader compile error:', info);
      throw info;
    }
    return s;
  }
  function link(vs, fs){
    const p = gl.createProgram();
    gl.attachShader(p, vs);
    gl.attachShader(p, fs);
    gl.bindAttribLocation(p, 0, 'a_pos');
    gl.linkProgram(p);
    if(!gl.getProgramParameter(p, gl.LINK_STATUS)){
      const info = gl.getProgramInfoLog(p);
      console.error('Program link error:', info);
      throw info;
    }
    return p;
  }

  // vertex shader (same for webgl1/2)
  const vsSrc = `attribute vec2 a_pos; void main(){ gl_Position = vec4(a_pos,0.0,1.0); }`;

  // fragment: simpler single-pass fractal (keeps things compatible)
  const fsSrc = `
    precision highp float;
    uniform vec2 u_resolution;
    uniform float u_time;
    uniform vec2 u_center;
    uniform float u_scale;
    uniform int u_maxIter;
    uniform int u_formula;
    uniform float u_power;
    uniform vec2 u_juliaC;
    uniform float u_seed;
    uniform float u_symmetry;
    uniform int u_mirror;
    uniform sampler2D u_palette;
    uniform float u_tweak;
    varying vec2 v_uv;
    // fallback varyings for webgl1 - emulate v_uv
    void mainImage(out vec4 fragColor, vec2 fragCoord);
    void main(){
      vec2 fragCoord = gl_FragCoord.xy;
      vec4 col; mainImage(col, fragCoord); gl_FragColor = col;
    }
    float rand1(vec2 co){ return fract(sin(dot(co, vec2(12.9898,78.233))) * 43758.5453 + u_seed*0.0001); }
    vec3 pal(float t){ return texture2D(u_palette, vec2(fract(t),0.5)).rgb; }
    vec2 cpow(vec2 z, float p){
      float r = length(z); float th = atan(z.y,z.x);
      float rp = pow(r,p); return vec2(rp*cos(th*p), rp*sin(th*p));
    }
    vec2 apply_sym(vec2 z, float slices, int mirror){
      if(slices <= 1.5) return z;
      float theta = atan(z.y, z.x);
      float r = length(z);
      float slice = 6.28318530718 / slices;
      theta = mod(theta + 1e-6, slice);
      if(mirror==1 && theta > slice*0.5) theta = slice - theta;
      return vec2(r*cos(theta), r*sin(theta));
    }
    float iterateFractal(vec2 c){
      int maxI = u_maxIter; vec2 z = vec2(0.0); float mu = float(maxI);
      if(u_formula==3){ z = c; for(int i=0;i<4096;i++){ if(i>=maxI) break; if(u_power==2.0){ z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + u_juliaC; } else { z = cpow(z,u_power) + u_juliaC; } float r2 = dot(z,z); if(r2>256.0){ float r=sqrt(r2); mu = float(i)+1.0 - log(log(r))/log(max(u_power,2.0)); break; } } }
      else if(u_formula==2){ z = vec2(0.0); for(int i=0;i<4096;i++){ if(i>=maxI) break; z = vec2(abs(z.x), abs(z.y)); vec2 z2 = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c; z = z2; float r2=dot(z,z); if(r2>256.0){ float r=sqrt(r2); mu=float(i)+1.0 - log(log(r))/log(2.0); break; } } }
      else if(u_formula==4){ z = vec2(0.0); for(int i=0;i<4096;i++){ if(i>=maxI) break; vec2 znew = vec2(sin(z.x*z.x - z.y*z.y) + c.x, tan(2.0*z.x*z.y) + c.y); z = znew; float r2 = dot(z,z); if(!isfinite(r2) || r2>1e5){ float r=sqrt(min(r2,1e5)); mu=float(i)+1.0 - log(max(1e-6, log(r)))/log(2.0); break; } } }
      else { z = vec2(0.0); for(int i=0;i<4096;i++){ if(i>=maxI) break; if(u_power==2.0){ z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c; } else { z = cpow(z,u_power) + c; } float r2 = dot(z,z); if(r2>256.0){ float r=sqrt(r2); mu=float(i)+1.0 - log(log(r))/log(max(u_power,2.0)); break; } } }
      return mu;
    }
    void mainImage(out vec4 fragColor, vec2 fragCoord){
      vec2 uv = (fragCoord - 0.5*u_resolution)/u_resolution.y;
      vec2 z = uv * u_scale + u_center;
      z = apply_sym(z, u_symmetry, u_mirror);
      z += (rand1(fragCoord) - 0.5) * u_tweak;
      float mu = iterateFractal(z);
      float iterNorm = clamp(mu/float(u_maxIter), 0.0, 1.0);
      float t = pow(iterNorm, 0.7);
      vec3 col;
      if(mu >= float(u_maxIter) - 0.5) col = vec3(0.02) + 0.2*pal(t*0.5); else col = pal(t + 0.02*sin(u_time*0.0004 + t*12.0));
      float d = length((fragCoord/u_resolution) - 0.5);
      col *= 1.0 - smoothstep(0.55, 0.95, d);
      fragColor = vec4(col,1.0);
    }
  `;

  // compile & link
  const vert = compile(gl.VERTEX_SHADER, vsSrc);
  const frag = compile(gl.FRAGMENT_SHADER, fsSrc);
  const prog = link(vert, frag);

  // quad setup
  const quad = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, quad);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,1,1]), gl.STATIC_DRAW);

  function setAttribs(){
    gl.bindBuffer(gl.ARRAY_BUFFER, quad);
    const loc = gl.getAttribLocation(prog, 'a_pos');
    gl.enableVertexAttribArray(loc);
    gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);
  }

  // safe resize with min sizes
  function resize(){
    const DPR = Math.min(2, window.devicePixelRatio || 1);
    const wCSS = Math.max(320, window.innerWidth);
    const hCSS = Math.max(240, window.innerHeight);
    const targetW = Math.min(3840, Math.max(2, Math.floor(wCSS * DPR)));
    const targetH = Math.min(2160, Math.max(2, Math.floor(hCSS * DPR)));
    canvas.width = targetW; canvas.height = targetH;
    canvas.style.width = wCSS + 'px'; canvas.style.height = hCSS + 'px';
    gl.viewport(0,0,targetW,targetH);
    return {w: targetW, h: targetH};
  }

  let res = resize();
  window.addEventListener('resize', ()=> { res = resize(); });

  // palette 1D texture creation (guaranteed >=1 width)
  function makePaletteCanvas(seed){
    const size = 256;
    const cvs = document.createElement('canvas'); cvs.width = size; cvs.height = 1;
    const ctx2 = cvs.getContext('2d');
    const img = ctx2.createImageData(size,1);
    // seeded rnd
    let a = seed|0;
    function rnd(){ a = (a + 0x6D2B79F5)|0; let t = Math.imul(a ^ a>>>15, 1 | a); t = (t + Math.imul(t ^ t>>>7, 61 | t) ^ t) >>> 0; return t/4294967296; }
    const baseHue = rnd()*360;
    const bands = 3 + Math.floor(rnd()*4);
    const anchors = [];
    for(let i=0;i<bands;i++) anchors.push({pos:i/(bands-1), h:(baseHue + (rnd()*120 - 60))%360, s:0.6+rnd()*0.4, v:0.4+rnd()*0.6});
    for(let i=0;i<size;i++){
      const t = i/(size-1);
      let j=1; while(j<anchors.length && anchors[j].pos < t) j++;
      const a0 = anchors[j-1], b0 = anchors[Math.min(j, anchors.length-1)];
      const local = (t - a0.pos) / Math.max(1e-6, (b0.pos - a0.pos));
      let dh = ((b0.h - a0.h + 540) % 360) - 180;
      let h = (a0.h + dh*local + 360) % 360;
      let s = a0.s + (b0.s - a0.s)*local; let v = a0.v + (b0.v - a0.v)*local;
      // hsv->rgb
      let c = hsvToRgb(h,s,v);
      img.data[i*4+0]=c[0]; img.data[i*4+1]=c[1]; img.data[i*4+2]=c[2]; img.data[i*4+3]=255;
    }
    ctx2.putImageData(img,0,0); return cvs;
  }
  function hsvToRgb(h,s,v){
    h=(h%360+360)%360; s=Math.max(0,Math.min(1,s)); v=Math.max(0,Math.min(1,v));
    const c=v*s; const x=c*(1-Math.abs((h/60)%2 - 1)); const m=v-c;
    let r=0,g=0,b=0;
    if(h<60){ r=c; g=x; b=0; } else if(h<120){ r=x; g=c; b=0; } else if(h<180){ r=0; g=c; b=x; }
    else if(h<240){ r=0; g=x; b=c; } else if(h<300){ r=x; g=0; b=c; } else { r=c; g=0; b=x; }
    return [Math.round((r+m)*255), Math.round((g+m)*255), Math.round((b+m)*255)];
  }

  // upload palette to GPU
  let paletteTex = gl.createTexture();
  function uploadPalette(seed){
    const cvs = makePaletteCanvas(seed);
    gl.bindTexture(gl.TEXTURE_2D, paletteTex);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, cvs);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  }

  // default random params
  let seed = Math.floor(Math.random()*1e9);
  uploadPalette(seed);
  let params = {
    centerX: -0.5 + (Math.random()*2 -1) * 0.6,
    centerY: (Math.random()*2 -1) * 0.4,
    scale: 3.5 * Math.pow(1.3, Math.random()*8),
    maxIter: 400 + Math.floor(Math.random()*600),
    formula: Math.floor(Math.random()*5),
    power: 2 + Math.random()*4,
    juliaC: [(Math.random()*2-1)*1.1, (Math.random()*2-1)*1.1],
    symmetry: 3 + Math.floor(Math.random()*10),
    mirror: Math.random()>.5?1:0,
    tweak: 0.0006 + Math.random()*0.003
  };

  // uniform setters
  function setUniforms(time){
    gl.useProgram(prog);
    gl.uniform2f(gl.getUniformLocation(prog,'u_resolution'), canvas.width, canvas.height);
    gl.uniform1f(gl.getUniformLocation(prog,'u_time'), time);
    gl.uniform2f(gl.getUniformLocation(prog,'u_center'), params.centerX, params.centerY);
    gl.uniform1f(gl.getUniformLocation(prog,'u_scale'), params.scale);
    gl.uniform1i(gl.getUniformLocation(prog,'u_maxIter'), params.maxIter);
    gl.uniform1i(gl.getUniformLocation(prog,'u_formula'), params.formula);
    gl.uniform1f(gl.getUniformLocation(prog,'u_power'), params.power);
    gl.uniform2f(gl.getUniformLocation(prog,'u_juliaC'), params.juliaC[0], params.juliaC[1]);
    gl.uniform1f(gl.getUniformLocation(prog,'u_seed'), seed);
    gl.uniform1f(gl.getUniformLocation(prog,'u_symmetry'), params.symmetry);
    gl.uniform1i(gl.getUniformLocation(prog,'u_mirror'), params.mirror);
    gl.uniform1f(gl.getUniformLocation(prog,'u_tweak'), params.tweak);
    // bind palette as unit 0
    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, paletteTex);
    gl.uniform1i(gl.getUniformLocation(prog,'u_palette'), 0);
  }

  // animation & interactions
  let last = performance.now();
  let autoZoom = {on:false, dir:1, speed: 0.998};
  // pointer pan
  let down=false, lastPos=null;
  canvas.addEventListener('pointerdown', e => { down=true; lastPos={x:e.clientX,y:e.clientY}; canvas.setPointerCapture(e.pointerId); });
  canvas.addEventListener('pointermove', e => {
    if(!down) return;
    const dx = e.clientX - lastPos.x, dy = e.clientY - lastPos.y;
    lastPos = {x:e.clientX,y:e.clientY};
    const vw = params.scale;
    params.centerX -= (dx / canvas.clientWidth) * vw;
    params.centerY += (dy / canvas.clientHeight) * vw * (canvas.clientHeight/canvas.clientWidth);
  });
  window.addEventListener('pointerup', ()=> { down=false; lastPos = null; });

  // wheel zoom around cursor
  canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    const delta = Math.sign(e.deltaY);
    const rect = canvas.getBoundingClientRect();
    const px = (e.clientX - rect.left) / rect.width;
    const py = (e.clientY - rect.top) / rect.height;
    const zoomFactor = Math.pow(1.02, delta * 8.0);
    const wx = (px - 0.5) * params.scale * (canvas.height/canvas.width) + params.centerX;
    const wy = (0.5 - py) * params.scale + params.centerY;
    params.centerX = wx + (params.centerX - wx) * zoomFactor;
    params.centerY = wy + (params.centerY - wy) * zoomFactor;
    params.scale *= zoomFactor;
  }, {passive:false});

  // touch pinch handling (simple)
  let lastDist = 0;
  canvas.addEventListener('touchstart', e => {
    if(e.touches.length===2){
      const a=e.touches[0], b=e.touches[1];
      lastDist = Math.hypot(a.clientX-b.clientX, a.clientY-b.clientY);
    }
  }, {passive:true});
  canvas.addEventListener('touchmove', e => {
    if(e.touches.length===2){
      e.preventDefault();
      const a=e.touches[0], b=e.touches[1];
      const dist = Math.hypot(a.clientX-b.clientX, a.clientY-b.clientY);
      if(lastDist>0){
        const zoomFactor = lastDist / dist;
        const cx = (a.clientX + b.clientX)/2, cy = (a.clientY + b.clientY)/2;
        const rect = canvas.getBoundingClientRect();
        const px=(cx-rect.left)/rect.width, py=(cy-rect.top)/rect.height;
        const wx = (px - 0.5) * params.scale * (canvas.height/canvas.width) + params.centerX;
        const wy = (0.5 - py) * params.scale + params.centerY;
        params.centerX = wx + (params.centerX - wx) * zoomFactor;
        params.centerY = wy + (params.centerY - wy) * zoomFactor;
        params.scale *= zoomFactor;
      }
      lastDist = dist;
    }
  }, {passive:false});
  canvas.addEventListener('touchend', ()=> lastDist=0);

  // double-tap toggles auto zoom
  let lastTap = 0;
  canvas.addEventListener('pointerup', (e)=>{ const now = performance.now(); if(now - lastTap < 360){ autoZoom.on = !autoZoom.on; if(autoZoom.on) autoZoom.dir = Math.random()>0.5?1:-1; } lastTap = now; });

  // small randomize on 'r' key (debug)
  window.addEventListener('keydown', e => { if(e.key==='r' || e.key==='R') randomizeAll(); });

  function randomizeAll(){
    seed = Math.floor(Math.random()*1e9);
    uploadPalette(seed);
    params.formula = Math.floor(Math.random()*5);
    params.power = 2 + Math.random()*4;
    params.juliaC = [(Math.random()*2-1)*1.1, (Math.random()*2-1)*1.1];
    params.symmetry = 3 + Math.floor(Math.random()*10);
    params.mirror = Math.random()>.5?1:0;
    params.tweak = 0.0006 + Math.random()*0.003;
    params.maxIter = 200 + Math.floor(Math.random()*800);
    params.centerX = -0.5 + (Math.random()*2 -1) * 0.7;
    params.centerY = (Math.random()*2 -1) * 0.6;
    params.scale = 3.5 * Math.pow(1.3, Math.random()*8);
    // small visible blink to ensure user sees change
    // (do not show text)
  }

  // main render loop
  function frame(t){
    try{
      // ensure resize
      res = resize();
      setUniforms(t);
      setAttribs();
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    } catch(err){
      console.error('GL render error', err);
      logErr('Render error — switching to CPU fallback');
      // fallback
      try{ startCPU(); } catch(e){ console.error('CPU fallback also failed', e); }
      return;
    }
    // subtle auto zoom & drift
    if(autoZoom.on) params.scale *= autoZoom.dir === 1 ? autoZoom.speed : 1/autoZoom.speed;
    params.centerX += Math.sin((t + seed)%10000 * 0.0001) * 0.0000015;
    params.centerY += Math.cos((t + seed*0.7)%12000 * 0.000095) * 0.0000012;
    requestAnimationFrame(frame);
  }

  // try one draw; if shaders fail unexpectedly, notify
  try {
    requestAnimationFrame(frame);
  } catch(e){
    console.error('Initial GL draw failed', e);
    logErr('WebGL error — falling back to CPU');
    startCPU();
  }
}
</script>
</body>
</html>
